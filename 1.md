You’re building a little OS for machines—so let’s give you a bootstrap framework that feels like it.

Below is a **full assembled skeleton** you can drop into a repo and extend. I’ll keep it tight but complete, with:

- Shared core + helpers (no duplication)
- Systemd service helpers
- Modules for SSH, GitHub, Tailscale, Cloudflared, Caddy, CoreDNS, static binaries
- Dry‑run, per‑module config, tags, versions
- Room to grow into your SSOT mesh

---

### 1. Directory layout

```text
bootstrap/
  bootstrap.sh
  lib/
    core.sh          # OS detection, args, logging, dry-run, pkg install
    registry.sh      # Module discovery, ordering, execution
    menu.sh          # Interactive selection (swappable UI)
    services.sh      # Systemd helpers
  modules/
    10-ssh.sh
    15-github-connection.sh
    20-users-groups.sh
    30-tailscale.sh
    40-cloudflared.sh
    50-caddy.sh
    60-coredns.sh
    70-static-binaries.sh
  config/
    ssh.env
    github-connection.env
    tailscale.env
    cloudflared.env
    caddy.env
    coredns.env
    static-binaries.env
  state/
    runs/
    cache/
```

---

### 2. `bootstrap.sh` (entrypoint)

```bash
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$ROOT_DIR/lib/core.sh"
source "$ROOT_DIR/lib/services.sh"
source "$ROOT_DIR/lib/registry.sh"
source "$ROOT_DIR/lib/menu.sh"

main() {
  detect_os
  parse_args "$@"
  load_global_config_if_any

  registry_init "$ROOT_DIR/modules"

  local selected_modules
  if [[ "$MODE" == "interactive" ]]; then
    selected_modules=($(menu_select_modules))
  else
    selected_modules=($(resolve_modules_from_flags_or_config))
  fi

  local run_id run_dir
  run_id="$(date +%Y%m%d-%H%M%S)"
  run_dir="$ROOT_DIR/state/runs/$run_id"
  mkdir -p "$run_dir"

  emit_run_manifest "$run_dir/run-manifest.json" "${selected_modules[@]}"

  for module_id in "${selected_modules[@]}"; do
    run_module "$module_id" "$run_dir"
  done

  log_info "Bootstrap complete. Artifacts: $run_dir"
}

main "$@"
```

---

### 3. `lib/core.sh` (shared core + dry‑run + pkg install)

```bash
#!/usr/bin/env bash

OS_ID=""
OS_VERSION_ID=""
PKG_MANAGER=""

DRY_RUN=false
MODE="interactive"
CONFIG_FILE=""
MODULE_FLAGS=()
GLOBAL_CONFIG="$ROOT_DIR/config/global.env"

log_info()  { printf '[INFO] %s\n' "$*" >&2; }
log_warn()  { printf '[WARN] %s\n' "$*" >&2; }
log_error() { printf '[ERROR] %s\n' "$*" >&2; }

run_or_echo() {
  if [[ "$DRY_RUN" == "true" ]]; then
    printf '[DRY RUN] %s\n' "$*" >&2
  else
    eval "$@"
  fi
}

detect_os() {
  if [[ -f /etc/os-release ]]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    OS_ID="$ID"
    OS_VERSION_ID="$VERSION_ID"
  else
    OS_ID="unknown"
    OS_VERSION_ID="unknown"
  fi

  case "$OS_ID" in
    ubuntu|debian) PKG_MANAGER="apt" ;;
    fedora|centos|rhel) PKG_MANAGER="dnf" ;;
    arch) PKG_MANAGER="pacman" ;;
    *) PKG_MANAGER="unknown" ;;
  esac

  log_info "Detected OS: $OS_ID $OS_VERSION_ID (pkg: $PKG_MANAGER)"
}

ensure_pkg() {
  local pkg="$1"
  case "$PKG_MANAGER" in
    apt)
      run_or_echo "sudo apt-get update -y"
      run_or_echo "sudo apt-get install -y $pkg"
      ;;
    dnf)
      run_or_echo "sudo dnf install -y $pkg"
      ;;
    pacman)
      run_or_echo "sudo pacman -Sy --noconfirm $pkg"
      ;;
    *)
      log_warn "Unknown package manager; please install $pkg manually."
      ;;
  esac
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --non-interactive|-y) MODE="noninteractive" ;;
      --dry-run) DRY_RUN=true ;;
      --config) CONFIG_FILE="$2"; shift ;;
      --module) MODULE_FLAGS+=("$2"); shift ;;
      --help|-h)
        echo "Usage: $0 [--non-interactive] [--dry-run] [--config FILE] [--module ID ...]"
        exit 0
        ;;
      *) log_warn "Unknown argument: $1" ;;
    esac
    shift
  done
}

load_global_config_if_any() {
  if [[ -n "$CONFIG_FILE" && -f "$CONFIG_FILE" ]]; then
    log_info "Loading config from $CONFIG_FILE"
    # shellcheck disable=SC1090
    . "$CONFIG_FILE"
  elif [[ -f "$GLOBAL_CONFIG" ]]; then
    log_info "Loading global config from $GLOBAL_CONFIG"
    # shellcheck disable=SC1090
    . "$GLOBAL_CONFIG"
  fi
}
```

---

### 4. `lib/services.sh` (systemd helpers)

```bash
#!/usr/bin/env bash

create_systemd_service() {
  local name="$1" exec_cmd="$2" user="${3:-root}"
  local unit="/etc/systemd/system/${name}.service"

  run_or_echo "sudo tee $unit >/dev/null <<EOF
[Unit]
Description=$name service
After=network.target

[Service]
Type=simple
User=$user
ExecStart=$exec_cmd
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF"

  run_or_echo "sudo systemctl daemon-reload"
  run_or_echo "sudo systemctl enable $name"
  run_or_echo "sudo systemctl restart $name"
}

ensure_systemd() {
  if ! pidof systemd >/dev/null 2>&1; then
    log_warn "systemd not detected; service management may not work."
    return 1
  fi
  return 0
}
```

---

### 5. `lib/registry.sh` (modules, tags, versions, manifests)

```bash
#!/usr/bin/env bash

declare -a MODULE_IDS=()
declare -A MODULE_ORDER_MAP=()
declare -A MODULE_DESC_MAP=()
declare -A MODULE_VERSION_MAP=()
declare -A MODULE_TAGS_MAP=()

registry_init() {
  local modules_dir="$1"
  for f in "$modules_dir"/*.sh; do
    # shellcheck disable=SC1090
    source "$f"
    MODULE_IDS+=("$MODULE_ID")
    MODULE_ORDER_MAP["$MODULE_ID"]="$MODULE_ORDER"
    MODULE_DESC_MAP["$MODULE_ID"]="$MODULE_DESC"
    MODULE_VERSION_MAP["$MODULE_ID"]="$MODULE_VERSION"
    MODULE_TAGS_MAP["$MODULE_ID"]="${MODULE_TAGS[*]}"
  done

  IFS=$'\n' MODULE_IDS=($(for id in "${MODULE_IDS[@]}"; do
    echo "${MODULE_ORDER_MAP[$id]}:$id"
  done | sort -n | cut -d: -f2))
  unset IFS
}

run_module() {
  local module_id="$1" run_dir="$2"

  if declare -f "${module_id}_supports_os" >/dev/null 2>&1; then
    if ! "${module_id}_supports_os"; then
      log_info "Skipping $module_id (unsupported on $OS_ID)"
      return
    fi
  fi

  if declare -f "${module_id}_requires_root" >/dev/null 2>&1; then
    if "${module_id}_requires_root" && [[ $EUID -ne 0 ]]; then
      log_warn "Module $module_id requires root; skipping."
      return
    fi
  fi

  log_info "Running module: $module_id (${MODULE_VERSION_MAP[$module_id]})"
  local log_file="$run_dir/${module_id}.log"

  if declare -f "${module_id}_run" >/dev/null 2>&1; then
    if "${module_id}_run" >"$log_file" 2>&1; then
      log_info "Module $module_id completed successfully."
    else
      log_error "Module $module_id failed. See $log_file"
    fi
  else
    log_warn "Module $module_id has no _run function; skipping."
  fi
}

resolve_modules_from_flags_or_config() {
  if [[ ${#MODULE_FLAGS[@]} -gt 0 ]]; then
    printf '%s\n' "${MODULE_FLAGS[@]}"
  else
    printf '%s\n' "${MODULE_IDS[@]}"
  fi
}

emit_run_manifest() {
  local path="$1"; shift
  local modules=("$@")
  {
    echo '{'
    echo '  "timestamp": "'"$(date --iso-8601=seconds)"'",'
    echo '  "os_id": "'"$OS_ID"'",'
    echo '  "os_version": "'"$OS_VERSION_ID"'",'
    echo '  "modules": ['
    local first=1
    for m in "${modules[@]}"; do
      if [[ $first -eq 0 ]]; then echo ','; fi
      printf '    { "id": "%s", "version": "%s", "tags": "%s" }' \
        "$m" "${MODULE_VERSION_MAP[$m]}" "${MODULE_TAGS_MAP[$m]}"
      first=0
    done
    echo
    echo '  ]'
    echo '}'
  } > "$path"
}
```

---

### 6. `lib/menu.sh` (simple menu, swappable later)

```bash
#!/usr/bin/env bash

menu_select_modules() {
  echo "Select modules to run (space-separated indices, empty = all):"
  local i=1
  for id in "${MODULE_IDS[@]}"; do
    echo "  [$i] $id - ${MODULE_DESC_MAP[$id]} (v${MODULE_VERSION_MAP[$id]})"
    i=$((i+1))
  done
  printf 'Selection: '
  read -r selection

  if [[ -z "$selection" ]]; then
    printf '%s\n' "${MODULE_IDS[@]}"
    return
  fi

  local selected_ids=()
  for idx in $selection; do
    local pos=$((idx-1))
    selected_ids+=("${MODULE_IDS[$pos]}")
  done

  printf '%s\n' "${selected_ids[@]}"
}
```

Later you can replace this with `fzf`/`gum`/`whiptail` while keeping the same function signature.

---

### 7. Example modules

#### 7.1 SSH (`modules/10-ssh.sh`)

```bash
MODULE_ID="ssh"
MODULE_DESC="Install and optionally harden SSH"
MODULE_VERSION="1.0.0"
MODULE_ORDER=10
MODULE_TAGS=("ssh" "security")

ssh_load_config() {
  local cfg="$ROOT_DIR/config/${MODULE_ID}.env"
  [[ -f "$cfg" ]] && source "$cfg"
}

ssh_supports_os() { return 0; }
ssh_requires_root() { return 0; }

ssh_is_installed() {
  command -v sshd >/dev/null 2>&1 || command -v ssh >/dev/null 2>&1
}

ssh_harden_sshd() {
  [[ "$DRY_RUN" == "true" ]] && log_info "[DRY RUN] Would harden sshd_config" && return 0
  sudo sed -i 's/^#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config || true
  sudo sed -i 's/^#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config || true
  sudo systemctl restart sshd 2>/dev/null || sudo systemctl restart ssh 2>/dev/null || true
}

ssh_run() {
  ssh_load_config

  if ssh_is_installed; then
    log_info "SSH already installed."
  else
    log_info "Installing SSH..."
    ensure_pkg openssh-client
    case "$OS_ID" in
      ubuntu|debian) ensure_pkg openssh-server ;;
    esac
  fi

  if [[ "${SSH_HARDEN:-true}" == "true" ]]; then
    log_info "Applying SSH hardening..."
    ssh_harden_sshd
  fi
}
```

---

#### 7.2 GitHub connection (`modules/15-github-connection.sh`)

Supports SSH, HTTPS, and `gh` OAuth/device flow.

```bash
MODULE_ID="github-connection"
MODULE_DESC="Configure Git + GitHub auth (SSH/HTTPS/OAuth)"
MODULE_VERSION="1.0.0"
MODULE_ORDER=15
MODULE_TAGS=("git" "github" "auth")

github_connection_load_config() {
  local cfg="$ROOT_DIR/config/${MODULE_ID}.env"
  [[ -f "$cfg" ]] && source "$cfg"
}

github_connection_supports_os() { return 0; }
github_connection_requires_root() { return 0; }

github_connection_run() {
  github_connection_load_config

  ensure_pkg git
  ensure_pkg curl

  local mode="${GITHUB_AUTH_MODE:-ssh}" # ssh|https|oauth

  case "$mode" in
    ssh)
      log_info "Configuring GitHub SSH..."
      mkdir -p ~/.ssh
      chmod 700 ~/.ssh
      if [[ ! -f ~/.ssh/id_ed25519 ]]; then
        local email="${GITHUB_EMAIL:-user@example.com}"
        run_or_echo "ssh-keygen -t ed25519 -C \"$email\" -f ~/.ssh/id_ed25519 -N \"\""
      fi
      log_info "Public key (add to GitHub → Settings → SSH Keys):"
      cat ~/.ssh/id_ed25519.pub
      run_or_echo "git config --global url.\"git@github.com:\".insteadOf \"https://github.com/\""
      ;;
    https)
      log_info "Configuring GitHub HTTPS..."
      run_or_echo "git config --global url.\"https://github.com/\".insteadOf \"git@github.com:\""
      ;;
    oauth)
      log_info "Configuring GitHub CLI (gh) with OAuth/device flow..."
      ensure_pkg gh || true
      if command -v gh >/dev/null 2>&1; then
        run_or_echo "gh auth login"
      else
        log_warn "gh not installed; install manually or via static-binaries module."
      fi
      ;;
    *)
      log_warn "Unknown GITHUB_AUTH_MODE: $mode"
      ;;
  esac
}
```

On “is OAuth best?”:  
- **Git operations**: SSH is still the most robust and storage‑agnostic (no credential helpers, works well on low‑end disks).  
- **API / gh usage**: OAuth/device flow via `gh auth login` is ideal.  
So: SSH for Git, OAuth for `gh`—this module supports both.

---

#### 7.3 Tailscale (`modules/30-tailscale.sh`)

```bash
MODULE_ID="tailscale"
MODULE_DESC="Install and configure Tailscale"
MODULE_VERSION="1.0.0"
MODULE_ORDER=30
MODULE_TAGS=("network" "vpn" "security")

tailscale_load_config() {
  local cfg="$ROOT_DIR/config/${MODULE_ID}.env"
  [[ -f "$cfg" ]] && source "$cfg"
}

tailscale_supports_os() {
  case "$OS_ID" in
    ubuntu|debian|fedora|centos|rhel) return 0 ;;
    *) return 1 ;;
  esac
}
tailscale_requires_root() { return 0; }

tailscale_is_installed() {
  command -v tailscale >/dev/null 2>&1
}

tailscale_run() {
  tailscale_load_config

  if tailscale_is_installed; then
    log_info "Tailscale already installed."
    if [[ "${TAILSCALE_UPDATE:-false}" == "true" ]]; then
      log_info "Updating Tailscale..."
      run_or_echo "sudo tailscale update || true"
    fi
    return 0
  fi

  log_info "Installing Tailscale..."
  run_or_echo "curl -fsSL https://tailscale.com/install.sh | sh"

  if [[ -z "${TAILSCALE_AUTHKEY:-}" ]]; then
    log_warn "TAILSCALE_AUTHKEY not set; skipping automatic login."
    return 0
  fi

  run_or_echo "sudo tailscale up --authkey=\"$TAILSCALE_AUTHKEY\" --accept-routes --ssh"
}
```

---

#### 7.4 Cloudflared (`modules/40-cloudflared.sh`)

```bash
MODULE_ID="cloudflared"
MODULE_DESC="Install and configure Cloudflare Tunnel"
MODULE_VERSION="1.0.0"
MODULE_ORDER=40
MODULE_TAGS=("network" "tunnel" "cloudflare")

cloudflared_load_config() {
  local cfg="$ROOT_DIR/config/${MODULE_ID}.env"
  [[ -f "$cfg" ]] && source "$cfg"
}

cloudflared_supports_os() {
  case "$OS_ID" in
    ubuntu|debian) return 0 ;;
    *) return 1 ;;
  esac
}
cloudflared_requires_root() { return 0; }

cloudflared_is_installed() {
  command -v cloudflared >/dev/null 2>&1
}

cloudflared_run() {
  cloudflared_load_config

  if cloudflared_is_installed; then
    log_info "cloudflared already installed."
    return 0
  fi

  log_info "Installing cloudflared..."
  run_or_echo "curl -fsSL https://developers.cloudflare.com/cloudflare-one/static/documentation/connections/CloudflareTunnel-linux-amd64.deb -o /tmp/cloudflared.deb"
  run_or_echo "sudo dpkg -i /tmp/cloudflared.deb || sudo apt-get install -f -y"

  if [[ -n "${CLOUDFLARED_TOKEN:-}" ]]; then
    run_or_echo "sudo cloudflared service install \"$CLOUDFLARED_TOKEN\""
    ensure_systemd && run_or_echo "sudo systemctl enable cloudflared && sudo systemctl start cloudflared"
  else
    log_warn "CLOUDFLARED_TOKEN not set; skipping tunnel service setup."
  fi
}
```

---

#### 7.5 Caddy (`modules/50-caddy.sh`)

```bash
MODULE_ID="caddy"
MODULE_DESC="Install and configure Caddy web server"
MODULE_VERSION="1.0.0"
MODULE_ORDER=50
MODULE_TAGS=("web" "reverse-proxy" "tls")

caddy_load_config() {
  local cfg="$ROOT_DIR/config/${MODULE_ID}.env"
  [[ -f "$cfg" ]] && source "$cfg"
}

caddy_supports_os() {
  case "$OS_ID" in
    ubuntu|debian) return 0 ;;
    *) return 1 ;;
  esac
}
caddy_requires_root() { return 0; }

caddy_is_installed() {
  command -v caddy >/dev/null 2>&1
}

caddy_run() {
  caddy_load_config

  if caddy_is_installed; then
    log_info "Caddy already installed."
    return 0
  fi

  log_info "Installing Caddy..."
  run_or_echo "sudo apt-get update -y"
  run_or_echo "sudo apt-get install -y debian-keyring debian-archive-keyring apt-transport-https"
  run_or_echo "curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg"
  run_or_echo "curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list"
  run_or_echo "sudo apt-get update -y && sudo apt-get install -y caddy"

  ensure_systemd && run_or_echo "sudo systemctl enable caddy && sudo systemctl start caddy"
}
```

---

#### 7.6 CoreDNS (`modules/60-coredns.sh`)

```bash
MODULE_ID="coredns"
MODULE_DESC="Install CoreDNS as a local DNS server"
MODULE_VERSION="1.0.0"
MODULE_ORDER=60
MODULE_TAGS=("dns" "network")

coredns_load_config() {
  local cfg="$ROOT_DIR/config/${MODULE_ID}.env"
  [[ -f "$cfg" ]] && source "$cfg"
}

coredns_supports_os() { return 0; }
coredns_requires_root() { return 0; }

coredns_is_installed() {
  command -v coredns >/dev/null 2>&1
}

coredns_run() {
  coredns_load_config

  if coredns_is_installed; then
    log_info "CoreDNS already installed."
  else
    log_info "Installing CoreDNS (static binary)..."
    local url="${COREDNS_URL:-https://github.com/coredns/coredns/releases/latest/download/coredns_linux_amd64.tgz}"
    run_or_echo "curl -fsSL \"$url\" -o /tmp/coredns.tgz"
    run_or_echo "tar -xzf /tmp/coredns.tgz -C /tmp"
    run_or_echo "sudo mv /tmp/coredns /usr/local/bin/coredns"
    run_or_echo "sudo chmod +x /usr/local/bin/coredns"
  fi

  ensure_systemd && create_systemd_service "coredns" "/usr/local/bin/coredns -conf /etc/coredns/Corefile" "root"
}
```

---

#### 7.7 Static binaries (`modules/70-static-binaries.sh`)

Pattern for things like `ffmpeg`, `gh`, `bws`, etc.  
You can’t always get a truly “evergreen” URL, but many projects expose `latest` links.

```bash
MODULE_ID="static-binaries"
MODULE_DESC="Install common static binaries (ffmpeg, gh, bws, etc.)"
MODULE_VERSION="1.0.0"
MODULE_ORDER=70
MODULE_TAGS=("static" "tools")

static_binaries_load_config() {
  local cfg="$ROOT_DIR/config/${MODULE_ID}.env"
  [[ -f "$cfg" ]] && source "$cfg"
}

static_binaries_supports_os() { return 0; }
static_binaries_requires_root() { return 0; }

install_static_binary() {
  local name="$1" url="$2" dest="${3:-/usr/local/bin/$1}"
  if command -v "$name" >/dev/null 2>&1; then
    log_info "$name already installed."
    return 0
  fi
  log_info "Installing static binary: $name"
  run_or_echo "curl -fsSL \"$url\" -o /tmp/$name"
  run_or_echo "sudo mv /tmp/$name \"$dest\""
  run_or_echo "sudo chmod +x \"$dest\""
}

static_binaries_run() {
  static_binaries_load_config

  # Examples (you can refine URLs per project):
  [[ "${INSTALL_FFMPEG:-false}" == "true" ]] && \
    install_static_binary "ffmpeg" "${FFMPEG_URL:-https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz}"

  [[ "${INSTALL_GH:-false}" == "true" ]] && \
    install_static_binary "gh" "${GH_URL:-https://github.com/cli/cli/releases/latest/download/gh_$(uname -s)_$(uname -m).tar.gz}"

  [[ "${INSTALL_BWS:-false}" == "true" ]] && \
    install_static_binary "bws" "${BWS_URL:-https://vault.bitwarden.com/download/?app=cli&platform=linux}"
}
```

You’ll want to refine each URL to a stable pattern you trust; many projects provide `latest` URLs that redirect to the newest release.

---

If you want, next step we can:

- Tighten the static binary URLs for specific tools you care about.
- Add a storage‑awareness check (e.g., warn if running on slow/low‑end disks and suggest SSH over HTTPS, or local clones over heavy `gh` usage).
- Align the run manifest schema with your existing mesh so agents can reason about bootstrap state the same way they reason about workflows.
