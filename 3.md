You’re building a real bootstrap agent now—let’s wire in the observability and planning layer.

I’ll focus on the *framework changes* and one example module; you can apply the pattern to the rest.

---

### 1. New global concepts

We’ll add:

- **status per module**
- **duration_ms per module**
- **host_id / node_id**
- **agent_id**
- **`--plan` mode** (no execution, just intent graph)
- **per‑module result manifests**
- **explicit `run_dir` + `MODULE_TMP` threading**

---

### 2. Core: host/node/agent + plan mode

Update `lib/core.sh`:

```bash
#!/usr/bin/env bash

OS_ID=""
OS_VERSION_ID=""
PKG_MANAGER=""

DRY_RUN=false
PLAN_MODE=false
MODE="interactive"
CONFIG_FILE=""
MODULE_FLAGS=()
GLOBAL_CONFIG="$ROOT_DIR/config/global.env"

GLOBAL_RUN_ID=""
GLOBAL_RUN_DIR=""
STORAGE_CLASS="unknown"
TMP_WORKDIR=""

HOST_ID="$(hostname -f 2>/dev/null || hostname)"
NODE_ID="${NODE_ID:-$HOST_ID}"
AGENT_ID="${AGENT_ID:-manual}"

log_info()  { printf '[INFO] %s\n' "$*" >&2; }
log_warn()  { printf '[WARN] %s\n' "$*" >&2; }
log_error() { printf '[ERROR] %s\n' "$*" >&2; }

run_or_echo() {
  if [[ "$PLAN_MODE" == "true" || "$DRY_RUN" == "true" ]]; then
    printf '[PLAN] %s\n' "$*" >&2
  else
    eval "$@"
  fi
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --non-interactive|-y) MODE="noninteractive" ;;
      --dry-run) DRY_RUN=true ;;
      --plan) PLAN_MODE=true; DRY_RUN=true ;;  # plan implies dry-run
      --config) CONFIG_FILE="$2"; shift ;;
      --module) MODULE_FLAGS+=("$2"); shift ;;
      --agent-id) AGENT_ID="$2"; shift ;;
      --node-id) NODE_ID="$2"; shift ;;
      --help|-h)
        echo "Usage: $0 [--non-interactive] [--dry-run] [--plan] [--config FILE] [--module ID ...] [--agent-id ID] [--node-id ID]"
        exit 0
        ;;
      *) log_warn "Unknown argument: $1" ;;
    esac
    shift
  done
}
```

Add storage + tmpfs helpers (as before), then:

```bash
bootstrap_global_init() {
  detect_os
  detect_storage_class
  init_temp_workdir

  GLOBAL_RUN_ID="$(date +%Y%m%d-%H%M%S)"
  GLOBAL_RUN_DIR="$ROOT_DIR/state/runs/$GLOBAL_RUN_ID"
  mkdir -p "$GLOBAL_RUN_DIR"

  trap 'on_exit' EXIT
}

on_exit() {
  local status=$?
  if [[ $status -ne 0 ]]; then
    log_error "Bootstrap exited with status $status"
  fi
  cleanup_temp_workdir
}
```

---

### 3. Registry: per‑module status, duration, manifests

Update `lib/registry.sh`:

```bash
#!/usr/bin/env bash

declare -a MODULE_IDS=()
declare -A MODULE_ORDER_MAP=()
declare -A MODULE_DESC_MAP=()
declare -A MODULE_VERSION_MAP=()
declare -A MODULE_TAGS_MAP=()

registry_init() {
  local modules_dir="$1"
  for f in "$modules_dir"/*.sh; do
    # shellcheck disable=SC1090
    source "$f"
    MODULE_IDS+=("$MODULE_ID")
    MODULE_ORDER_MAP["$MODULE_ID"]="$MODULE_ORDER"
    MODULE_DESC_MAP["$MODULE_ID"]="$MODULE_DESC"
    MODULE_VERSION_MAP["$MODULE_ID"]="$MODULE_VERSION"
    MODULE_TAGS_MAP["$MODULE_ID"]="${MODULE_TAGS[*]}"
  done

  IFS=$'\n' MODULE_IDS=($(for id in "${MODULE_IDS[@]}"; do
    echo "${MODULE_ORDER_MAP[$id]}:$id"
  done | sort -n | cut -d: -f2))
  unset IFS
}

module_init_common() {
  local module_id="$1" run_dir="$2"
  local module_tmp="$TMP_WORKDIR/$module_id"
  mkdir -p "$module_tmp"
  echo "$module_tmp"
}

run_module() {
  local module_id="$1" run_dir="$2"

  # plan mode: just emit intent
  if [[ "$PLAN_MODE" == "true" ]]; then
    emit_module_plan_manifest "$run_dir" "$module_id"
    log_info "[PLAN] Would run module: $module_id"
    return
  fi

  local supports_fn="${module_id}_supports_os"
  local requires_root_fn="${module_id}_requires_root"
  local run_fn="${module_id}_run"

  if declare -f "$supports_fn" >/dev/null 2>&1; then
    if ! "$supports_fn"; then
      log_info "Skipping $module_id (unsupported on $OS_ID)"
      emit_module_result_manifest "$run_dir" "$module_id" "skipped_unsupported" 0
      return
    fi
  fi

  if declare -f "$requires_root_fn" >/dev/null 2>&1; then
    if "$requires_root_fn" && [[ $EUID -ne 0 ]]; then
      log_warn "Module $module_id requires root; skipping."
      emit_module_result_manifest "$run_dir" "$module_id" "skipped_not_root" 0
      return
    fi
  fi

  log_info "Running module: $module_id (${MODULE_VERSION_MAP[$module_id]})"
  local log_file="$run_dir/${module_id}.log"
  local start_ms end_ms duration_ms
  start_ms=$(date +%s%3N)

  local module_tmp
  module_tmp="$(module_init_common "$module_id" "$run_dir")"

  if declare -f "$run_fn" >/dev/null 2>&1; then
    if "$run_fn" "$run_dir" "$module_tmp" >"$log_file" 2>&1; then
      end_ms=$(date +%s%3N)
      duration_ms=$((end_ms - start_ms))
      log_info "Module $module_id completed successfully in ${duration_ms}ms."
      emit_module_result_manifest "$run_dir" "$module_id" "success" "$duration_ms"
    else
      end_ms=$(date +%s%3N)
      duration_ms=$((end_ms - start_ms))
      log_error "Module $module_id failed in ${duration_ms}ms. See $log_file"
      emit_module_result_manifest "$run_dir" "$module_id" "failure" "$duration_ms"
    fi
  else
    log_warn "Module $module_id has no _run function; skipping."
    emit_module_result_manifest "$run_dir" "$module_id" "skipped_no_run" 0
  fi
}

emit_run_manifest() {
  local path="$1"; shift
  local modules=("$@")
  {
    echo '{'
    echo '  "kind": "bootstrap-run",'
    echo '  "version": "1.1.0",'
    echo '  "run_id": "'"$GLOBAL_RUN_ID"'",'
    echo '  "timestamp": "'"$(date --iso-8601=seconds)"'",'
    echo '  "host_id": "'"$HOST_ID"'",'
    echo '  "node_id": "'"$NODE_ID"'",'
    echo '  "agent_id": "'"$AGENT_ID"'",'
    echo '  "os": {'
    echo '    "id": "'"$OS_ID"'",'
    echo '    "version": "'"$OS_VERSION_ID"'",'
    echo '    "storage_class": "'"$STORAGE_CLASS"'"'
    echo '  },'
    echo '  "modules": ['
    local first=1
    for m in "${modules[@]}"; do
      if [[ $first -eq 0 ]]; then echo ','; fi
      printf '    { "id": "%s", "version": "%s", "tags": [%s] }' \
        "$m" "${MODULE_VERSION_MAP[$m]}" \
        "$(printf '"%s"' ${MODULE_TAGS_MAP[$m]})"
      first=0
    done
    echo
    echo '  ]'
    echo '}'
  } > "$path"
}

emit_module_result_manifest() {
  local run_dir="$1" module_id="$2" status="$3" duration_ms="$4"
  local path="$run_dir/${module_id}.result.json"
  {
    echo '{'
    echo '  "kind": "bootstrap-module-result",'
    echo '  "run_id": "'"$GLOBAL_RUN_ID"'",'
    echo '  "module_id": "'"$module_id"'",'
    echo '  "version": "'"${MODULE_VERSION_MAP[$module_id]}"'",'
    echo '  "status": "'"$status"'",'
    echo '  "duration_ms": '"$duration_ms",'
    echo '  "host_id": "'"$HOST_ID"'",'
    echo '  "node_id": "'"$NODE_ID"'",'
    echo '  "agent_id": "'"$AGENT_ID"'"'
    echo '}'
  } > "$path"
}

emit_module_plan_manifest() {
  local run_dir="$1" module_id="$2"
  local path="$run_dir/${module_id}.plan.json"
  {
    echo '{'
    echo '  "kind": "bootstrap-module-plan",'
    echo '  "run_id": "'"$GLOBAL_RUN_ID"'",'
    echo '  "module_id": "'"$module_id"'",'
    echo '  "version": "'"${MODULE_VERSION_MAP[$module_id]}"'",'
    echo '  "host_id": "'"$HOST_ID"'",'
    echo '  "node_id": "'"$NODE_ID"'",'
    echo '  "agent_id": "'"$AGENT_ID"'",'
    echo '  "intended_actions": []'
    echo '}'
  } > "$path"
}
```

You can later populate `intended_actions` from inside modules if you want richer planning.

---

### 4. Thread `run_dir` + `MODULE_TMP` into modules

New module signature:

```bash
# module_id_run() {
#   local run_dir="$1"
#   local module_tmp="$2"
#   ...
# }

ssh_run() {
  local run_dir="$1"
  local module_tmp="$2"

  ssh_load_config

  # use "$module_tmp" for any temp files
  # use run_or_echo for actions
}
```

Every module now gets:

- `run_dir` → where manifests/logs live
- `module_tmp` → its own scratch space under the chosen tmpfs/volume

---

### 5. `--plan` mode

Already wired:

- `--plan` sets `PLAN_MODE=true` and `DRY_RUN=true`
- `run_module` skips execution and writes `*.plan.json` per module
- Logs show `[PLAN]` lines instead of executing

Agents can:

- Run `bootstrap.sh --plan --module tailscale --agent-id mesh-planner`
- Read `state/runs/<id>/tailscale.plan.json`
- Decide whether to approve/execute later

---

This gives you:

- Mesh‑ready artifacts (run + per‑module result/plan)
- Explicit module lifecycle with temp dirs and traps
- Storage‑aware behavior
- A clean path to richer planning (`intended_actions`) when you’re ready

If you want, next step we can define a concrete `intended_actions` schema (e.g., “install_pkg”, “write_file”, “create_service”) so your planner agents can reason about changes before they happen.
