You’re basically turning this into a first‑class “machine bootstrap agent.” Let’s wire in the last pieces cleanly.

---

### 1. Tightened static binary URLs (ffmpeg, gh, bws, etc.)

Update `modules/70-static-binaries.sh`:

```bash
MODULE_ID="static-binaries"
MODULE_DESC="Install common static binaries (ffmpeg, gh, bws, etc.)"
MODULE_VERSION="1.0.1"
MODULE_ORDER=70
MODULE_TAGS=("static" "tools")

static_binaries_load_config() {
  local cfg="$ROOT_DIR/config/${MODULE_ID}.env"
  [[ -f "$cfg" ]] && source "$cfg"
}

static_binaries_supports_os() { return 0; }
static_binaries_requires_root() { return 0; }

install_static_binary() {
  local name="$1" url="$2" dest="${3:-/usr/local/bin/$1}"
  if command -v "$name" >/dev/null 2>&1; then
    log_info "$name already installed."
    return 0
  fi
  log_info "Installing static binary: $name from $url"
  run_or_echo "curl -fsSL \"$url\" -o /tmp/${name}.tgz"
  # You can branch per-tool if needed; here assume single binary or tarball:
  case "$name" in
    ffmpeg)
      run_or_echo "tar -xJf /tmp/${name}.tgz -C /tmp"
      run_or_echo "sudo mv /tmp/ffmpeg*/ffmpeg \"$dest\""
      ;;
    gh)
      run_or_echo "tar -xzf /tmp/${name}.tgz -C /tmp"
      run_or_echo "sudo mv /tmp/gh_*/bin/gh \"$dest\""
      ;;
    bws)
      run_or_echo "sudo mv /tmp/${name}.tgz \"$dest\""
      ;;
    *)
      run_or_echo "sudo mv /tmp/${name}.tgz \"$dest\""
      ;;
  esac
  run_or_echo "sudo chmod +x \"$dest\""
}

static_binaries_run() {
  static_binaries_load_config

  # ffmpeg static (John Van Sickle)
  [[ "${INSTALL_FFMPEG:-false}" == "true" ]] && \
    install_static_binary "ffmpeg" \
      "${FFMPEG_URL:-https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz}"

  # GitHub CLI (gh) latest
  [[ "${INSTALL_GH:-false}" == "true" ]] && \
    install_static_binary "gh" \
      "${GH_URL:-https://github.com/cli/cli/releases/latest/download/gh_$(uname -s)_$(uname -m).tar.gz}"

  # Bitwarden CLI (bws)
  [[ "${INSTALL_BWS:-false}" == "true" ]] && \
    install_static_binary "bws" \
      "${BWS_URL:-https://vault.bitwarden.com/download/?app=cli&platform=linux}"
}
```

You can refine per‑tool extraction logic as you lock in your preferred binaries.

---

### 2. Storage‑awareness + tmpfs detection + mktemp override

Extend `lib/core.sh`:

```bash
STORAGE_CLASS="unknown"
TMP_WORKDIR=""

detect_storage_class() {
  # crude but useful: check root fs type + size
  local fs line
  fs=$(df -T / | awk 'NR==2 {print $2}')
  local size_gb
  size_gb=$(df -BG / | awk 'NR==2 {gsub(/G/,"",$2); print $2}')

  if [[ "$fs" == "tmpfs" ]]; then
    STORAGE_CLASS="tmpfs"
  elif (( size_gb <= 20 )); then
    STORAGE_CLASS="low"
  else
    STORAGE_CLASS="normal"
  fi

  log_info "Storage class: $STORAGE_CLASS (${size_gb}G, fs=$fs)"

  if [[ "$STORAGE_CLASS" == "low" ]]; then
    log_warn "Low-capacity root; prefer SSH over HTTPS and avoid heavy gh clones."
  fi
}

is_tmpfs_and_usable() {
  local path="$1"
  local fstype
  fstype=$(df -T "$path" 2>/dev/null | awk 'NR==2 {print $2}')
  [[ "$fstype" != "tmpfs" ]] && return 1

  # check write + space (~2GB)
  local testdir="$path/bootstrap-tmp-test.$$"
  mkdir -p "$testdir" 2>/dev/null || return 1
  dd if=/dev/zero of="$testdir/test.bin" bs=1M count=16 status=none 2>/dev/null || { rm -rf "$testdir"; return 1; }
  local avail_gb
  avail_gb=$(df -BG "$path" | awk 'NR==2 {gsub(/G/,"",$4); print $4}')
  rm -rf "$testdir"
  (( avail_gb >= 2 ))
}

init_temp_workdir() {
  detect_storage_class

  local candidates=("/dev/shm" "/run" "/tmp")
  for c in "${candidates[@]}"; do
    if is_tmpfs_and_usable "$c"; then
      TMP_WORKDIR="$(mktemp -d "$c/bootstrap.XXXXXX")"
      break
    fi
  done

  if [[ -z "$TMP_WORKDIR" ]]; then
    TMP_WORKDIR="$(mktemp -d)"
  fi

  log_info "Using temp workdir: $TMP_WORKDIR"
}

cleanup_temp_workdir() {
  if [[ -n "${TMP_WORKDIR:-}" && -d "$TMP_WORKDIR" ]]; then
    rm -rf "$TMP_WORKDIR"
  fi
}
```

Call `detect_storage_class` + `init_temp_workdir` from a shared init (next section).

---

### 3. Global trap + per‑module init

Add to `lib/core.sh`:

```bash
GLOBAL_RUN_DIR=""
GLOBAL_RUN_ID=""

bootstrap_global_init() {
  detect_os
  detect_storage_class
  init_temp_workdir

  GLOBAL_RUN_ID="$(date +%Y%m%d-%H%M%S)"
  GLOBAL_RUN_DIR="$ROOT_DIR/state/runs/$GLOBAL_RUN_ID"
  mkdir -p "$GLOBAL_RUN_DIR"

  trap 'on_exit' EXIT
}

on_exit() {
  local status=$?
  if [[ $status -ne 0 ]]; then
    log_error "Bootstrap exited with status $status"
  fi
  cleanup_temp_workdir
}
```

Update `bootstrap.sh` to use it:

```bash
main() {
  bootstrap_global_init
  parse_args "$@"
  load_global_config_if_any

  registry_init "$ROOT_DIR/modules"

  local selected_modules
  if [[ "$MODE" == "interactive" ]]; then
    selected_modules=($(menu_select_modules))
  else
    selected_modules=($(resolve_modules_from_flags_or_config))
  fi

  local run_dir="$GLOBAL_RUN_DIR"
  emit_run_manifest "$run_dir/run-manifest.json" "${selected_modules[@]}"

  for module_id in "${selected_modules[@]}"; do
    run_module "$module_id" "$run_dir"
  done

  log_info "Bootstrap complete. Artifacts: $run_dir"
}
```

Per‑module init helper (in `lib/registry.sh` or a new `lib/module.sh`):

```bash
module_init_common() {
  local module_id="$1" run_dir="$2"
  local module_tmp="$TMP_WORKDIR/$module_id"
  mkdir -p "$module_tmp"
  echo "$module_tmp"
}
```

Modules can call:

```bash
local MODULE_TMP
MODULE_TMP="$(module_init_common "$MODULE_ID" "$run_dir")"
# use $MODULE_TMP for downloads/cache
```

(You can pass `run_dir` into `_run` via environment or function signature if you want; right now we log per‑module to `run_dir` already.)

---

### 4. Storage‑aware GitHub auth recommendation

In `github-connection` module, you can branch on `STORAGE_CLASS`:

```bash
github_connection_run() {
  github_connection_load_config

  ensure_pkg git
  ensure_pkg curl

  local mode="${GITHUB_AUTH_MODE:-ssh}" # ssh|https|oauth

  if [[ "$STORAGE_CLASS" == "low" ]]; then
    log_info "Low storage detected; preferring SSH for Git and avoiding heavy gh clones."
    [[ "$mode" == "https" ]] && mode="ssh"
  fi

  case "$mode" in
    ssh)   # as before...
      ;;
    https) # as before...
      ;;
    oauth) # as before...
      ;;
  esac
}
```

This gives you a gentle, automatic nudge toward SSH on constrained disks.

---

### 5. Align run manifest schema with your mesh

Right now `emit_run_manifest` is close; let’s make it more “mesh‑ready”:

```bash
emit_run_manifest() {
  local path="$1"; shift
  local modules=("$@")
  {
    echo '{'
    echo '  "kind": "bootstrap-run",'
    echo '  "version": "1.0.0",'
    echo '  "run_id": "'"$GLOBAL_RUN_ID"'",'
    echo '  "timestamp": "'"$(date --iso-8601=seconds)"'",'
    echo '  "os": {'
    echo '    "id": "'"$OS_ID"'",'
    echo '    "version": "'"$OS_VERSION_ID"'",'
    echo '    "storage_class": "'"$STORAGE_CLASS"'"'
    echo '  },'
    echo '  "modules": ['
    local first=1
    for m in "${modules[@]}"; do
      if [[ $first -eq 0 ]]; then echo ','; fi
      printf '    { "id": "%s", "version": "%s", "tags": [%s] }' \
        "$m" "${MODULE_VERSION_MAP[$m]}" \
        "$(printf '"%s"' ${MODULE_TAGS_MAP[$m]})"
      first=0
    done
    echo
    echo '  ]'
    echo '}'
  } > "$path"
}
```

You can later extend this with:

- `status` per module (success/failure)
- `duration_ms`
- `host_id` / `node_id`
- `agent_id` (if a mesh agent invoked it)

That gives your agents a consistent artifact shape across workflows and bootstrap runs.

---

If you want, next step we can:

- Thread `run_dir` and `MODULE_TMP` explicitly into each `_run` function.
- Add per‑module result manifests (so agents can see exactly what changed).
- Add a `--plan` mode that emits a JSON “intended actions” graph without executing anything.
