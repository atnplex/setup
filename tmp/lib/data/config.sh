#!/usr/bin/env bash
# Module: data/config
# Version: 0.1.0
# Provides: Config file loading, get/set, validation
# Requires: none
[[ -n "${_STDLIB_CONFIG:-}" ]] && return 0
declare -g _STDLIB_CONFIG=1

# ── Internal State ─────────────────────────────────────────────────────
declare -gA _CONFIG_STORE=()   # key → value

# ── stdlib::config::load ──────────────────────────────────────────────
# Load an env-style config file (KEY=VALUE, comments with #).
# Exports all keys to environment AND internal store.
# Usage: stdlib::config::load /path/to/config
stdlib::config::load() {
  local path="$1"
  [[ -f "$path" ]] || { echo "WARN: Config file not found: $path" >&2; return 1; }

  local line key val
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip blank lines and comments
    [[ -z "$line" || "$line" == \#* ]] && continue
    # Trim inline comments
    line="${line%%#*}"
    # Parse KEY=VALUE
    key="${line%%=*}"
    val="${line#*=}"
    # Strip surrounding quotes from value
    val="${val#\"}"; val="${val%\"}"
    val="${val#\'}"; val="${val%\'}"
    # Trim whitespace
    key="$(echo "$key" | xargs)"
    val="$(echo "$val" | xargs)"

    [[ -z "$key" ]] && continue

    _CONFIG_STORE["$key"]="$val"
    export "$key=$val"
  done < "$path"
}

# ── stdlib::config::get ───────────────────────────────────────────────
# Read a config value. Falls back to default if not set.
# Usage: stdlib::config::get KEY [default]
stdlib::config::get() {
  local key="$1"
  local default="${2:-}"

  if [[ -n "${_CONFIG_STORE[$key]+set}" ]]; then
    printf '%s' "${_CONFIG_STORE[$key]}"
  else
    printf '%s' "$default"
  fi
}

# ── stdlib::config::set ───────────────────────────────────────────────
# Set a config value in memory (and env).
stdlib::config::set() {
  local key="$1" value="$2"
  _CONFIG_STORE["$key"]="$value"
  export "$key=$value"
}

# ── stdlib::config::write ─────────────────────────────────────────────
# Write current config state to a file.
# Usage: stdlib::config::write /path/to/config
stdlib::config::write() {
  local path="$1"
  local tmpfile
  tmpfile=$(mktemp)

  echo "# Generated by stdlib::config at $(date -u +%Y-%m-%dT%H:%M:%SZ)" > "$tmpfile"
  for key in $(echo "${!_CONFIG_STORE[@]}" | tr ' ' '\n' | sort); do
    printf '%s="%s"\n' "$key" "${_CONFIG_STORE[$key]}" >> "$tmpfile"
  done

  mv "$tmpfile" "$path"
}

# ── stdlib::config::merge ─────────────────────────────────────────────
# Merge a config file without overwriting existing values.
# Usage: stdlib::config::merge /path/to/config
stdlib::config::merge() {
  local path="$1"
  [[ -f "$path" ]] || return 1

  local line key val
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ -z "$line" || "$line" == \#* ]] && continue
    line="${line%%#*}"
    key="${line%%=*}"
    val="${line#*=}"
    val="${val#\"}"; val="${val%\"}"
    val="${val#\'}"; val="${val%\'}"
    key="$(echo "$key" | xargs)"
    val="$(echo "$val" | xargs)"

    [[ -z "$key" ]] && continue

    # Only set if not already present
    if [[ -z "${_CONFIG_STORE[$key]+set}" ]]; then
      _CONFIG_STORE["$key"]="$val"
      export "$key=$val"
    fi
  done < "$path"
}

# ── stdlib::config::validate ──────────────────────────────────────────
# Validate a config value against a type.
# Usage: stdlib::config::validate KEY type   (type: string, int, bool, path, url)
stdlib::config::validate() {
  local key="$1" type="$2"
  local val
  val=$(stdlib::config::get "$key")

  [[ -z "$val" ]] && { echo "ERROR: Config key '$key' is not set" >&2; return 1; }

  case "$type" in
    string)  return 0 ;;  # Any non-empty string is valid
    int)     [[ "$val" =~ ^-?[0-9]+$ ]] || { echo "ERROR: '$key' is not an integer: $val" >&2; return 1; } ;;
    bool)    [[ "$val" =~ ^(true|false|yes|no|1|0)$ ]] || { echo "ERROR: '$key' is not a boolean: $val" >&2; return 1; } ;;
    path)    [[ -e "$val" ]] || { echo "ERROR: '$key' path does not exist: $val" >&2; return 1; } ;;
    url)     [[ "$val" =~ ^https?:// ]] || { echo "ERROR: '$key' is not a URL: $val" >&2; return 1; } ;;
    *)       echo "WARN: Unknown validation type: $type" >&2; return 1 ;;
  esac
}
