#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════════════════
# sys/secrets.sh — Secrets-first bootstrap flow (BWS + age + keyctl)
# ═══════════════════════════════════════════════════════════════════════
[[ -n "${_STDLIB_MOD_SECRETS:-}" ]] && return 0
readonly _STDLIB_MOD_SECRETS=1
_STDLIB_MOD_VERSION="1.0.0"

stdlib::import core/log

# ── Orchestrate full secrets bootstrap ───────────────────────────────
stdlib::secrets::bootstrap() {
  stdlib::secrets::install_bws
  stdlib::secrets::prompt_token
  stdlib::secrets::fetch
  stdlib::secrets::decrypt_to_keyctl
}

# ── Install BWS CLI (idempotent) ─────────────────────────────────────
stdlib::secrets::install_bws() {
  if command -v bws >/dev/null 2>&1; then
    stdlib::log::info "BWS CLI already installed"
    return 0
  fi

  stdlib::log::info "Installing BWS CLI..."
  local arch
  arch="$(uname -m)"
  case "${arch}" in
    x86_64)  arch="x86_64" ;;
    aarch64) arch="aarch64" ;;
    *)       stdlib::log::error "Unsupported arch for BWS: ${arch}"; return 1 ;;
  esac

  local tmp_zip="${TMP_DIR:-/tmp}/bws.zip"
  local bws_url="https://github.com/bitwarden/sdk-internal/releases/latest/download/bws-${arch}-unknown-linux-gnu.zip"

  if ! command -v curl >/dev/null 2>&1; then
    apt-get update -qq >/dev/null 2>&1
    apt-get install -yqq curl unzip >/dev/null 2>&1
  fi

  curl -fsSL "${bws_url}" -o "${tmp_zip}"
  unzip -oqq "${tmp_zip}" -d /usr/local/bin/
  chmod +x /usr/local/bin/bws
  rm -f "${tmp_zip}"

  stdlib::log::info "BWS CLI installed"
}

# ── Prompt for BWS Access Token ──────────────────────────────────────
stdlib::secrets::prompt_token() {
  if [[ -n "${BWS_ACCESS_TOKEN:-}" ]]; then
    stdlib::log::info "BWS_ACCESS_TOKEN already set"
    return 0
  fi

  printf '\n'
  printf 'Enter BWS Access Token: '
  read -rs BWS_ACCESS_TOKEN
  printf '\n'
  export BWS_ACCESS_TOKEN

  if [[ -z "${BWS_ACCESS_TOKEN}" ]]; then
    stdlib::log::error "BWS_ACCESS_TOKEN is empty"
    return 1
  fi

  stdlib::log::info "BWS token accepted"
}

# ── Fetch variables + secrets from BWS ───────────────────────────────
stdlib::secrets::fetch() {
  local ns_root="${NAMESPACE_ROOT:?NAMESPACE_ROOT not set}"
  local ignore_dir="${ns_root}/.ignore"
  mkdir -p "${ignore_dir}"

  VARIABLES_FILE="${ignore_dir}/variables.env"
  SECRETS_FILE="${ignore_dir}/secrets.age"
  export VARIABLES_FILE SECRETS_FILE

  stdlib::log::info "Fetching secrets from BWS..."

  local secrets_json
  secrets_json="$(bws secret list --output json 2>/dev/null)" || {
    stdlib::log::error "Failed to fetch secrets from BWS"
    return 1
  }

  # Write variables (unencrypted key=value)
  printf '# Generated by bootstrap — %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > "${VARIABLES_FILE}"
  printf '%s' "${secrets_json}" | \
    jq -r '.[] | select(.note == "variable") | "\(.key)=\(.value)"' \
    >> "${VARIABLES_FILE}" 2>/dev/null || true
  chmod 0600 "${VARIABLES_FILE}"

  # Write secrets (encrypted with age if available)
  if command -v age >/dev/null 2>&1 && [[ -n "${AGE_RECIPIENT:-}" ]]; then
    printf '%s' "${secrets_json}" | \
      jq -r '.[] | select(.note != "variable") | "\(.key)=\(.value)"' | \
      age -r "${AGE_RECIPIENT}" -o "${SECRETS_FILE}" 2>/dev/null
    chmod 0400 "${SECRETS_FILE}"
    stdlib::log::info "Secrets encrypted to ${SECRETS_FILE}"
  else
    local secrets_plain="${ignore_dir}/secrets.env"
    printf '# Generated by bootstrap — %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > "${secrets_plain}"
    printf '%s' "${secrets_json}" | \
      jq -r '.[] | select(.note != "variable") | "\(.key)=\(.value)"' \
      >> "${secrets_plain}" 2>/dev/null || true
    chmod 0400 "${secrets_plain}"
    SECRETS_FILE="${secrets_plain}"
    stdlib::log::warn "age not available — secrets written as plaintext"
  fi

  stdlib::log::info "Variables written to ${VARIABLES_FILE}"
}

# ── Decrypt secrets into kernel keyring ──────────────────────────────
stdlib::secrets::decrypt_to_keyctl() {
  if ! command -v keyctl >/dev/null 2>&1; then
    stdlib::log::warn "keyctl not available — skipping kernel keyring"
    return 0
  fi

  if [[ ! -f "${SECRETS_FILE:-}" ]]; then
    stdlib::log::warn "No secrets file to decrypt"
    return 0
  fi

  local key value
  if [[ "${SECRETS_FILE}" == *.age ]]; then
    if ! command -v age >/dev/null 2>&1; then
      stdlib::log::warn "age not available — cannot decrypt"
      return 0
    fi
    local decrypted
    decrypted="$(age -d -i "${AGE_IDENTITY:-/root/.age/key.txt}" "${SECRETS_FILE}" 2>/dev/null)" || {
      stdlib::log::error "Failed to decrypt ${SECRETS_FILE}"
      return 1
    }
    while IFS='=' read -r key value; do
      [[ -z "${key}" || "${key}" == \#* ]] && continue
      keyctl add user "bootstrap:${key}" "${value}" @s >/dev/null
    done <<< "${decrypted}"
  else
    while IFS='=' read -r key value; do
      [[ -z "${key}" || "${key}" == \#* ]] && continue
      keyctl add user "bootstrap:${key}" "${value}" @s >/dev/null
    done < "${SECRETS_FILE}"
  fi

  stdlib::log::info "Secrets loaded into kernel keyring"
}
