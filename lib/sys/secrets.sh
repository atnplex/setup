#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════════════════════════
# sys/secrets.sh — Secrets-first bootstrap flow (BWS + age + keyctl)
# ═══════════════════════════════════════════════════════════════════════════════
[[ -n "${_STDLIB_MOD_SECRETS:-}" ]] && return 0
readonly _STDLIB_MOD_SECRETS=1
_STDLIB_MOD_VERSION="1.0.0"

stdlib::import core/log

# ── Install BWS CLI (idempotent) ──────────────────────────────────────────────
stdlib::secrets::install_bws() {
  if command -v bws >/dev/null 2>&1; then
    stdlib::log::info "BWS CLI already installed"
    return 0
  fi

  stdlib::log::info "Installing BWS CLI..."
  local arch
  arch="$(uname -m)"
  case "${arch}" in
    x86_64)  arch="x86_64" ;;
    aarch64) arch="aarch64" ;;
    *)       stdlib::log::error "Unsupported arch for BWS: ${arch}"; return 1 ;;
  esac

  local tmp_zip="${TMP_DIR:-/tmp}/bws.zip"
  local bws_url="https://github.com/bitwarden/sdk-internal/releases/latest/download/bws-${arch}-unknown-linux-gnu.zip"

  if ! command -v curl >/dev/null 2>&1; then
    apt-get update -qq >/dev/null 2>&1
    apt-get install -yqq curl unzip >/dev/null 2>&1
  fi

  curl -fsSL "${bws_url}" -o "${tmp_zip}"
  unzip -oqq "${tmp_zip}" -d /usr/local/bin/
  chmod +x /usr/local/bin/bws
  rm -f "${tmp_zip}"

  stdlib::log::info "BWS CLI installed"
}

# ── Prompt for BWS Access Token ───────────────────────────────────────────────
stdlib::secrets::prompt_token() {
  if [[ -n "${BWS_ACCESS_TOKEN:-}" ]]; then
    stdlib::log::info "BWS_ACCESS_TOKEN already set"
    return 0
  fi

  printf '\n'
  printf 'Enter BWS Access Token: '
  read -rs BWS_ACCESS_TOKEN
  printf '\n'
  export BWS_ACCESS_TOKEN

  if [[ -z "${BWS_ACCESS_TOKEN}" ]]; then
    stdlib::log::error "BWS_ACCESS_TOKEN is empty"
    return 1
  fi

  stdlib::log::info "BWS token accepted"
}

# ── Fetch variables + secrets from BWS ────────────────────────────────────────
# Writes: $VARIABLES_FILE (unencrypted), $SECRETS_FILE (encrypted or plaintext)
stdlib::secrets::fetch() {
  # Derive NAMESPACE_ROOT early if not yet set
  NAMESPACE="${NAMESPACE:-atn}"
  NAMESPACE_ROOT="${NAMESPACE_ROOT:-/${NAMESPACE}}"
  export NAMESPACE NAMESPACE_ROOT

  local ignore_dir="${NAMESPACE_ROOT}/.ignore"
  mkdir -p "${ignore_dir}"

  VARIABLES_FILE="${ignore_dir}/variables.env"
  SECRETS_FILE="${ignore_dir}/secrets.age"
  export VARIABLES_FILE SECRETS_FILE

  stdlib::log::info "Fetching secrets from BWS..."

  local secrets_json
  secrets_json="$(bws secret list --output json 2>/dev/null)" || {
    stdlib::log::error "Failed to fetch secrets from BWS"
    return 1
  }

  # Write variables.env (unencrypted key=value)
  printf '# Generated by bootstrap — %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > "${VARIABLES_FILE}"
  printf '%s' "${secrets_json}" | \
    jq -r '.[] | select(.note == "variable") | "\(.key)=\(.value)"' \
    >> "${VARIABLES_FILE}" 2>/dev/null || true
  chmod 0600 "${VARIABLES_FILE}"
  stdlib::log::info "Wrote variables to ${VARIABLES_FILE}"

  # Write secrets.age (encrypted with age if available)
  if command -v age >/dev/null 2>&1 && [[ -n "${AGE_RECIPIENT:-}" ]]; then
    printf '%s' "${secrets_json}" | \
      jq -r '.[] | select(.note != "variable") | "\(.key)=\(.value)"' | \
      age -r "${AGE_RECIPIENT}" -o "${SECRETS_FILE}" 2>/dev/null
    chmod 0400 "${SECRETS_FILE}"
    stdlib::log::info "Wrote encrypted secrets to ${SECRETS_FILE}"
  else
    local secrets_plain="${ignore_dir}/secrets.env"
    printf '# Generated by bootstrap — %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > "${secrets_plain}"
    printf '%s' "${secrets_json}" | \
      jq -r '.[] | select(.note != "variable") | "\(.key)=\(.value)"' \
      >> "${secrets_plain}" 2>/dev/null || true
    chmod 0400 "${secrets_plain}"
    SECRETS_FILE="${secrets_plain}"
    export SECRETS_FILE
    stdlib::log::warn "age not available — secrets written as plaintext"
  fi
}

# ── Decrypt secrets into kernel keyring ───────────────────────────────────────
stdlib::secrets::decrypt_to_keyctl() {
  if ! command -v keyctl >/dev/null 2>&1; then
    stdlib::log::warn "keyctl not available — skipping kernel keyring"
    return 0
  fi

  if [[ ! -f "${SECRETS_FILE:-}" ]]; then
    stdlib::log::warn "No secrets file to decrypt"
    return 0
  fi

  local key value
  if [[ "${SECRETS_FILE}" == *.age ]]; then
    if ! command -v age >/dev/null 2>&1; then
      stdlib::log::warn "age not available — cannot decrypt"
      return 0
    fi
    local decrypted
    decrypted="$(age -d -i "${AGE_IDENTITY:-/root/.age/key.txt}" "${SECRETS_FILE}" 2>/dev/null)" || {
      stdlib::log::error "Failed to decrypt ${SECRETS_FILE}"
      return 1
    }
    while IFS='=' read -r key value; do
      [[ -z "${key}" || "${key}" == \#* ]] && continue
      keyctl add user "bootstrap:${key}" "${value}" @s >/dev/null
    done <<< "${decrypted}"
  else
    while IFS='=' read -r key value; do
      [[ -z "${key}" || "${key}" == \#* ]] && continue
      keyctl add user "bootstrap:${key}" "${value}" @s >/dev/null
    done < "${SECRETS_FILE}"
  fi

  stdlib::log::info "Secrets loaded into kernel keyring"
}

# ── Source variables.env into current environment ─────────────────────────────
stdlib::secrets::source_variables() {
  if [[ -z "${VARIABLES_FILE:-}" || ! -f "${VARIABLES_FILE}" ]]; then
    stdlib::log::warn "VARIABLES_FILE not set or missing — skipping source"
    return 0
  fi

  stdlib::log::info "Sourcing ${VARIABLES_FILE}"
  local line key value
  while IFS= read -r line || [[ -n "${line}" ]]; do
    line="${line%%\#*}"
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"
    [[ -z "${line}" ]] && continue
    key="${line%%=*}"
    value="${line#*=}"
    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"
    value="${value#\"}"; value="${value%\"}"
    value="${value#\'}"; value="${value%\'}"
    if [[ "${key}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
      export "${key}=${value}"
    fi
  done < "${VARIABLES_FILE}"

  stdlib::log::info "Variables sourced from ${VARIABLES_FILE}"
}
